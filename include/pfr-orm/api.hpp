#pragma once

#include <pfr-orm/detail/field.hpp>
#include <pfr-orm/detail/pfr.hpp>

#include <cstddef>
#include <cstdint>
#include <optional>
#include <string>
#include <string_view>

#include <boost/pfr.hpp>
#include <boost/pfr/config.hpp>

static_assert(BOOST_PFR_ENABLED, "Boost.PFR is not supported, cannot build");
static_assert(BOOST_PFR_CORE_NAME_ENABLED,
              "Boost.PFR does not support field name extraction, cannot build");

namespace pfrorm {

/// Identifier mode
enum class IdMode : std::uint8_t {
  Auto,   ///< Automatically generated by database
  Manual, ///< Provided when persisting
};

template <typename T> class FieldDescriptor {
public:
  [[nodiscard]] constexpr std::size_t get() const { return this->field; }

private:
  std::size_t field;

  constexpr FieldDescriptor(const std::size_t field) : field(field) {}

  template <detail::Reflectable C>
  friend constexpr FieldDescriptor<C>
  detail::getFieldDescriptor(const auto C::*, std::string_view);
};

// NOLINTNEXTLINE(cppcoreguidelines-macro-usage): TODO
#define PFRORM_FIELD(type, field)                                              \
  ::pfrorm::detail::getFieldDescriptor(&type::field, #field)

template <typename T> struct EntityRegistrationData {
  FieldDescriptor<T> id;
  IdMode idMode;
};

/// ORM entity registration
/// @tparam T registered type
template <typename T>
constexpr std::optional<EntityRegistrationData<T>> EntityRegistration =
    std::nullopt;

template <typename T> struct CompositeRegistrationData {};

/// ORM composite value registration
/// @tparam T registered type
template <typename T>
constexpr std::optional<CompositeRegistrationData<T>> CompositeRegistration =
    std::nullopt;

enum class NativeType : std::uint8_t {
  BigInt,
  String,
};

template <typename T> struct ValueRegistrationData {
  NativeType nativeType;
};

/// Basic value type mapping
/// @tparam T registered value type
template <typename T>
constexpr std::optional<ValueRegistrationData<T>> ValueRegistration =
    std::nullopt;

template <>
inline constexpr auto ValueRegistration<uint64_t> =
    ValueRegistrationData<uint64_t>{
        .nativeType = NativeType::BigInt,
    };

template <>
inline constexpr auto ValueRegistration<std::string> =
    ValueRegistrationData<std::string>{
        .nativeType = NativeType::String,
    };

/// Tag to be used with boost::pfr::is_reflectable*
struct ReflectionTag;

} // namespace pfrorm
